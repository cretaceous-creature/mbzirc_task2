#!/usr/bin/env roseus

(ros::load-ros-manifest "jsk_recognition_msgs")
(ros::load-ros-manifest "jsk_pcl_ros")
(ros::load-ros-manifest "opencv_apps")
(ros::load-ros-manifest "mzirc_task2_perception")
(ros::roseus "remove_shadow")

(load "package://hrpsys_ros_bridge_tutorials/euslisp/hrp2g-interface.l")
(load "package://mzirc_task2_perception/euslisp/approach-panel.l")

(setq initialize t)
(setq cluster-num 0)
(setq cluster-poses (list ))
(setq cluster-num-ref 0)
(setq cluster-poses-ref (list ))
(setq area-height 0)
(setq area-width 0)

(defun area-cb (msg)
  (setq cluster-num (list-length (send msg :areas)))
  (setq cluster-poses (send msg :areas))
  )

(defun img-cb (msg)
  (if (eq area-height 0)
      (progn
        (setq area-height (send msg :height))
        (setq area-width (send msg :width)))))

(ros::subscribe "/meanshift_filtering_line/areas" mzirc_task2_perception::AreaArrayStamped #'area-cb)
(ros::subscribe "/meanshift_filtering_line/output" sensor_msgs::Image #'img-cb)

(hrp2g-init)
(setq *robot* *hrp2g*)
(send *robot* :angle-vector (send *ri* :state :reference-vector))
(objects (list *robot*))

(defun rarm-up-pose ()
  (send *robot* :angle-vector #f(0.0 0.0 0.0 0.0 -87.3 -27.3 16.9 -93.0 -27.9 -6.4 82.0 15.0 10.0 10.0 0.0 -90.0 0.0 0.0 -10.0 -15.0))
  ;;(send *robot* :angle-vector #f(0.0 0.0 0.0 0.0 -88.2 -32.2 16.0 -103.6 -31.67 -10.75 91.0 15.0 10.0 10.0 0.0 -90.0 0.0 0.0 -10.0 -15.0))
  (send *ri* :angle-vector (send *robot* :angle-vector) 5000)
  )

(defun area-check (&key (timeout 100) (check-topic 3))
  (let* (cntr)
    (setq tmp-cluster-num 0)
    (setq tmp-cluster-poses (list ))
    (setq tmp-cb-cnt 0)
    (while (< tmp-cb-cnt check-topic)
      (setq cntr 0)
      (setq cluster-num 0)
      (ros::rate 10)
      (while (or (eq cluster-num 0)
                 (eq area-height 0))
        (ros::spin-once)
        (ros::sleep)
        (if (> (incf cntr) timeout)
            (progn
              (format t "failed subscribe topic!~%")
              (return-from area-check nil))))
      (if (eq tmp-cb-cnt 0)
          (progn (setq tmp-cluster-num cluster-num)
                 (setq tmp-cluster-poses cluster-poses)
                 (format t "init cluster tmp: ~A num: ~A~%" tmp-cluster-num cluster-num)
                 )
        (progn (if (eq tmp-cluster-num cluster-num)
                   (progn (format t "start push cluster~%")
                          (dotimes (i tmp-cluster-num)
                            (progn (send (elt tmp-cluster-poses i) :x
                                         (+ (send (elt tmp-cluster-poses i) :x) (send (elt cluster-poses i) :x)))
                                   (send (elt tmp-cluster-poses i) :y
                                         (+ (send (elt tmp-cluster-poses i) :y) (send (elt cluster-poses i) :y)))
                                   (send (elt tmp-cluster-poses i) :size
                                         (+ (send (elt tmp-cluster-poses i) :size) (send (elt cluster-poses i) :size)))))
                          (format t "end push cluster~%"))
                 (progn
                   (format t "the number of cluster error!~%")
                   (return-from area-check nil)))
               ))
      (incf tmp-cb-cnt)
      (if (eq tmp-cb-cnt check-topic) (return-from nil nil) t)
      )
    (format t "pass through loop~%")
    (dotimes (i tmp-cluster-num)
      (progn (send (elt cluster-poses i) :x
                   (/ (send (elt tmp-cluster-poses i) :x) check-topic))
             (send (elt cluster-poses i) :y
                   (/ (send (elt tmp-cluster-poses i) :y) check-topic))
             (send (elt cluster-poses i) :size
                   (/ (send (elt tmp-cluster-poses i) :size) check-topic))))
    (return-from area-check t)
    ))

(defun area-update (&key (timeout 100) (check-topic 1))
  (send *robot* :angle-vector (send *ri* :state :potentio-vector))
  ;;topic-cb
    (if initialize
        (progn ;;initialize
          (unless (area-check :timeout timeout :check-topic check-topic)
            (return-from area-update nil))
          (setq cluster-num-ref cluster-num)
          (setq cluster-poses-ref cluster-poses)
          (setq initialize nil))
      (progn ;;update
        (unless (area-check :timeout timeout :check-topic check-topic)
          (return-from area-update nil))
        (if (not (eq cluster-num cluster-num-ref))
          (progn ;;re-initialize
            (setq initialize t)
            (setq cluster-num-ref cluster-num)
            (setq cluster-poses-ref cluster-poses)
            ))))
    (return-from area-update t))

(defun move-judge (&key (thre 20))
  (if (not (eq cluster-num cluster-num-ref))
      (progn (format t "area data is empty!~%")
             (return-from move-judge t)))
  (let ((move nil))
    (block check-move
      (dotimes (i cluster-num)
        (if (or (> (abs (- (send (elt cluster-poses i) :x) (send (elt cluster-poses-ref i) :x))) thre)
                (> (abs (- (send (elt cluster-poses i) :y) (send (elt cluster-poses-ref i) :y))) thre))
            (progn (setq move t)
                   (return-from check-move t)))))
    (return-from move-judge move)
    ))

(defun move-hand (&key (arm :rarm) (dir 0) (step 50))
  (setq arm-pos (send *robot* arm :end-coords :copy-worldcoords))
  (if (eq dir 0) ;;0->right 1->left
      (send arm-pos :translate (float-vector 0 (- step) 0))
    (send arm-pos :translate (float-vector 0 step 0)))
  (send *robot* arm :inverse-kinematics arm-pos)
  (send *ri* :angle-vector (send *robot* :angle-vector) 4000)
  (send *ri* :wait-interpolation)
  )

(defun move-base-side (&key (dir 0) (step 0.2))
  (let (rot)
    (if (eq dir 0)
        (setq rot (- (/ PI 2)))
      (setq rot (/ PI 2)))
    (move-base step rot 10.0 :use-ri t)
    (move-base 0.0 (- rot) 10.0 :use-ri t)
    ))


(defun find-shadow ()
  (if (eq cluster-num-ref 0)
      (progn (format t "area data is empty!~%")
             (return-from find-shadow t)))
  (let (shadow-id shadow-y)
    (dotimes (i cluster-num-ref)
      (if (eq i 0)
          (progn
            (setq shadow-id 0)
            (setq shadow-y (send (elt cluster-poses-ref i) :y)))
        (progn
          (if (< shadow-y (send (elt cluster-poses-ref i) :y))
              (progn
                (setq shadow-id i)
                (setq shadow-y (send (elt cluster-poses-ref i) :y)))
            ))))
    (return-from find-shadow (elt cluster-poses-ref shadow-id))
    ))

(defun remove-shadow (&key (auto t))
  (setq initialize t)
  (setq cluster-num 0)
  (setq cluster-poses (list ))
  (setq cluster-num-ref 0)
  (setq cluster-poses-ref (list ))
  (setq area-height 0)
  (setq area-width 0)
  (let (move shadow dir (update nil) pre-dir (check nil))
    (setq move t)
    (setq check nil)
    (while (not check)
      (setq update nil)
      (while (not update)
        (setq update (area-update :timeout 300)))
      (format t "OK?~%")
      (if (y-or-n-p)
          (setq check t)
        (setq check nil)))
    ;;(while (not update)
    ;;(setq update (area-update :timeout 300)))
    (while move
      (if (not initialize)
          (progn
            (setq shadow (find-shadow))
            (if (> (send shadow :x) (/ area-width 2))
                (setq dir 0)
              (setq dir 1))
            (setq pre-dir dir))
        (setq dir pre-dir))
      (format t "try move~%")
      (if (not auto) (read-line))
      ;;(move-hand :dir dir)
      (move-base-side :dir dir :step 0.1)
      (unix::sleep 30)
      (format t "moved. ready?~%")
      (read-line);;finer-tune base if needed.
      (setq check nil)
      (while (not check)
        (setq update nil)
        (while (not update)
          (setq update (area-update :timeout 300)))
          (format t "OK?~%")
          (if (y-or-n-p)
              (setq check t)
            (setq check nil)))
      (if (not initialize)
          (progn
            (setq move (move-judge :thre 10))
            (format t "move-judge: ~A~%" move)
            (setq cluster-num-ref cluster-num)
            (setq cluster-poses-ref cluster-poses)))
      )
    ))
